# **C++ 筆記**  
## 貪心 Greedy  

貪心算法，是在每一步選擇中都採取 **當前最佳的選擇** ，希望最終能達到整個問題的最佳解。這種方法基於局部最優選擇，希望能導向全局最優解  

其實也就是在能確保 **未來最佳解** ，必定需要經過 **目前最佳解** 時，便可以使用貪心算法  

## 優點：  

1. 簡單易懂，易於實現  
2. 適用於某些特定類型的問題，如  
     * 活動選擇問題  
     * 最小生成樹問題（如 Kruskal 和 Prim 算法）  
     * 單源最短路徑問題（如 Dijkstra 算法）  

## 缺點：  

1. 不能保證對所有問題都能找到全局最優解  
2. 需要問題本身具有特定性質才能應用  

## 一些 Greedy 範例  

> ### 1. 最基本的 Greedy  
>桌上有 $N$ 個物品，第 $i$ 個物品有價值 $a_i$，你可以拿走 $K$ 個  
>在你想要最大化價值的情況底下，最大是多少？  

最直覺的想法是拿前 $K$ 大的，顯然這也是最好的辦法  
Greedy 的感覺就是訂好一個策略，往當下最好的走，嘗試看看會不會是最好的  

```mermaid
flowchart TD
A[初始化 totalValue = 0]
B[物品價值按照從大到小排序]
C[選擇前 K 個價值最大的物品]
D[累加這些物品的價值到 totalValue]
E[輸出 totalValue]

A --> B
B --> C
C --> D
D --> E

```

---

> ### 2. 找零錢問題  
> 有 $N$ 種幣值，第 $i$ 種幣值是 $b_i$ ，同時保證：  
> 
> 1. 對於 $1 \leq i < N$ ， 都有 $b_i > b_{i+1}$  
> 2. $b_{i+1}$ 整除 $b_i$  
> 3. $b_N = 1$  
> 
> 今天你是一個超商店員，你想用這些幣值湊出 $K$ 元，但你又不想給顧客太多零錢，因此你想找出零錢總數最少的方法  
> 給定 $N$ , $b_i$ , $K$ 請求出這個最小值是多少  

想想看生活中的解決方式  

從幣值最大的最多的開始嘗試拿，直到拿完為止  
這樣好像是對的，真的是對的嗎？  

我們把兩個不同的方案都按照幣值小的開始排序，定義 $A$ 是剛剛方法做出來的方案 $B$ 是任何其他的方案  

```mermaid
gantt
section 找錢方式
全部要找的錢 :active,  des1, 2000-1-1, 15d
方法 A：6   :         desA1, 2000-1-1, 6d
方法 A：6   :         desA2, 2000-1-7, 6d
方法 A：3   :         desA3, 2000-1-13, 3d
方法 B：6   :         desB1, 2000-1-1, 6d
方法 B：3   :         desB2, 2000-1-7, 3d
方法 B：3   :         desB3, 2000-1-10, 3d
方法 B：3   :         desB3, 2000-1-13, 3d
```

在第一個 $A$ 跟 $B$ 不一樣的地方來看，找 $A$ 的一個一定可以對應到 B 的一部分  

* 如果 $B$ 那部分的第一個比 $A$ 那部分的第一個大呢？  
  不可能發生,因為 $A$ 的策略是「從大的開始試」。  
* 如果 $A$ 的第一個對下去沒有完整的對到一些零錢呢？  
  不可能發生，因為小零錢可以整除大零錢，不可能沒對到。  
  
所以說,我們可以發現 $B$ 在這部分就輸了  
換句話說， $A$ 一定是最好的，Greedy 成功！  

```mermaid
flowchart TD
A[初始化 totalCoins = 0]
B[從幣值最大的開始]
C[如果 K >= 當前幣值]
D[計算所需的當前幣值的數量]
E[減去當前幣值的總數從 K 中]
F[增加當前幣值的總數到 totalCoins 中]
G[移動到下一個幣值]
H[檢查是否 K = 0]
I[結束，輸出 totalCoins]

A --> B
B --> C
C -->|是| D
C -->|否| G
D --> E
E --> F
F --> G
G --> H
H -->|否| B
H -->|是| I

```

---

> ### 2.ex. 找零錢問題（改）  
> 有 $N$ 種幣值，第 $i$ 種幣值是 $b_i$ ，~~同時保證：~~  
> 
> ~~1. 對於 $1 \leq i < N$ ， 都有 $b_i > b_{i+1}$~~  
> ~~2. $b_{i+1}$ 整除 $b_i$~~  
> ~~3. $b_N$ = $1$~~  
> 
> 今天你是一個超商店員，你想用這些幣值湊出 $K$ 元，但你又不想給顧客太多零錢，因此你想找出零錢總數最少的方法  
> 給定 $N$ , $b_i$ , $K$ 請求出這個最小值是多少  
> 
> 也就是之前保證的三點都不存在了  

那這樣同樣的 Greedy 還有效嗎？  

$N = 3$ ; $b = \{10, 9, 1\}$ ; $K = 27$  
可以發現你會找到一組不好的解  
用原本的方式找錢會找除 $\{10, 10, 1, 1, 1, 1, 1, 1, 1\}$ 共 $9$ 個零錢  
然而用手算一下會發現其實可以用 $\{9, 9, 9\}$ 共 $3$ 個零錢完成任務  
要怎麼解決這個問題？ 之後會講的DP就可以處理這個問題了！

---

> ### 3. 最大平均值問題
> 有一個長度是 $N$ 的陣列 $a$ ，你想要找出一個長度 $> 1$ 個連續子陣列使得他的平均最大  

* 枚舉頭尾 $O(N^2)$ ？  
* 對答案二分搜 $O(N log C)$ ？  
 
有沒有 $O(N)$ 的做法？  

爆搜之後可能會發現，好像答案的長度都不長，只有 $2$ 或 $3$ 而已  
只確定這樣的做法是好的嗎？  

假設陣列 $a = [1, 12, -5, -6, 50, 3]$  

長度為 2 的子陣列：  
* $[1, 12]$ 的平均值是 $6.5$  
* $[12, -5]$ 的平均值是 $3.5$  
* $[-5, -6]$ 的平均值是 $-5.5$  
* $[-6, 50]$ 的平均值是 $22$  
* $[50, 3]$ 的平均值是 $26.5$  

長度為 3 的子陣列：  
* $[1, 12, -5]$ 的平均值是 $2.67$  
* $[12, -5, -6]$ 的平均值是 $0.33$  
* $[-5, -6, 50]$ 的平均值是 $13$  
* $[-6, 50, 3]$ 的平均值是 $15.67$  

根據這個結果，我們可以說長度小於等於 $3$ 的子陣列就能找到最大平均值，這是因為較長的最佳子陣列必定包含一個更短的最佳子陣列  

這樣的方法是有效的，並且時間複雜度是 $O(N)$ ，因為我們只需要遍歷一次陣列，計算所有長度為 $2$ 和 $3$ 的子陣列的平均值  

因此，對任意長度大於 $4$ 的最佳解，我們一定可以把它剖成兩半，拿平均最大的那邊  

也就是說，如果有大於 $4$ 的長度最佳解，那一定有長度小於等於 $3$ 的最佳解  

```mermaid
flowchart TD
A[初始化 maxAvg = -∞, maxLen = 3]
B[遍歷陣列，計算所有長度為 2 和 3 的子陣列平均值]
C[對每個長度為 2 的子陣列]
D{子陣列平均值 > maxAvg}
E[更新 maxAvg 和子陣列]
F[對每個長度為 3 的子陣列]
G[結束，輸出結果]

A --> B
B --> C
C --> D
D -->|是| E
D -->|否| F
F --> G
E --> F

```

---

> ### 4. 保母問題
> 寶寶需要全天候的照顧，但是保姆卻不能全天候的工作  
> 有 $N$ 個保姆，第 $i$ 個可以在 $[Xi; Yi]$ 的時間照顧寶寶  
> 你最少需要聘請多少的保姆才能照顧好寶寶(或根本不可能)？  

1. 如果一個保姆很能工作，就優先請他？

反例:  
$N=3$ ; $(X;Y)= \{ (1; 1) ; (2; 109) ; (3; 109) \}$  
這樣會聘請到 $2$ $;$ $3$ $;$ $1$ ，但實際上後面 $2$ 個只需要其中 $1$ 個  

2. 假如把包含的都刪掉呢？

反例:  
$N = 5$ ; $(X;Y) = \{ (1;6) ; (2;7) ; (3;8) \}$  
在大家都一樣的時候，我們不知道要選哪個優先  

3. 重新觀察一遍:

時間 $1$ 一定有人需要來顧，所以我們先找顧的到 $1$ 的最好的那個  
接下來呢？

如果只是單純選能做最久的，我們會像剛剛一樣找到不是很好的解  

如果是找做最晚的呢？似乎就可以了... 嗎？

我們把兩個不同的方案都列出來看，定義 $A$ 是我們剛剛方法做出來的方案， $B$ 是任何其他的方案。

```mermaid
gantt
section 照顧的時間
全部要照顧的時間 :active,  des1, 2000-1-1, 24d
方法 A：12   :         desA1, 2000-1-1, 12d
方法 A：6   :         desA2, 2000-1-10, 6d
方法 A：9   :         desA3, 2000-1-16, 9d
方法 B：12   :         desB1, 2000-1-1, 12d
方法 B：5   :         desB2, 2000-1-10, 5d
方法 B：2   :         desB3, 2000-1-14, 2d
方法 B：9   :         desB4, 2000-1-16, 9d
```

在第一個 $A$ 跟 $B$ 不一樣的地方來看，我們一定會發現 $A$ 比 $B$ 不來的差  

* 如果 $B$ 那部分的第一個比 $A$ 那部分的第一個長呢？  

不可能發生，因為 $A$ 的策略是「從當下可以做最晚的開始試」  

* 如果 $B$ 那部分比 $A$ 那部分用的還要少呢？  

不可能發生，因為 $A$ 第一個在比 $B$ 更長的情況下， $A$ 是有辦法接上 $B$ 的那組解的，因為我們選的比 $B$ 那組解至少在下一步會找到可以做更晚的，如此反覆下去 $B$ 是沒有機會贏過 $A$ 的  

也就是說,剛剛的 Greedy 策略是好的，而且可以很輕鬆的用維護，總時間複雜度 $O(N \cdot log N)$  
我們重新思考一下構建這個策略的關鍵：「觀察到如果處理完 $[1; i]$ 之後，重點在 $i + 1$ 一定要有人顧」  

```mermaid
flowchart TD
A[排序保姆: 先按開始時間排序, 若開始時間相同則按結束時間排序]
B[初始化 currentEnd = 0]
C{currentEnd < T}
D[在所有開始時間 <= currentEnd 的保姆中]
E[選擇結束時間最晚的保姆]
F[更新 currentEnd 為該保姆的結束時間]
G[增加已選保姆數量]
H[檢查是否能覆蓋到 T]
I[輸出已選保姆數量]

A --> B --> C
C -->|是| D
D --> E
E --> F
F --> G
G --> H
H -->|否| C
H -->|是| I
```

---

> ### 4.ex. 保母問題（改）
> 寶寶需要全天候的照顧，但是保姆卻不能全天候的工作  
> 有 $N$ 個保姆，第 $i$ 個可以在 $[Xi; Yi]$ 的時間照顧寶寶  
> 而聘請他需要花費 $w_i$  
> 你最少需要花費多少錢才能照顧好寶寶(或根本不可能)？  

剛剛的 Greedy 策略現在已經不管用了，因為可能可以做很晚的很貴，但做一點點的便宜到爆炸  

這個問題該怎麼解決呢？  

沒錯，又是之後會講的DP就可以處理這個問題了！  

---

> ### 5. 最大不相交線斷問題
> 電影季要開跑了！在這場電影季中有 $N$ 部電影，第 $i$ 部播放的時間是 $[a_i; b_i]$  
> 在一個時間點你只能看一部電影，你最多能完整地看完多少部電影？

如果有很多部電影接下來可以看，要選擇哪一部？  

如果選最早開始的，可能會踩到電影其實超長的雷  
如果選最短的，可能會踩到電影超晚開始的雷  
如果選最晚結束的，是不是就做完了？  

我們把兩個不同的方案都列出來看，定義 $A$ 是我們剛剛方法做出來的方案， $B$ 是任何其他的方案。  
在第一個 $A$ 跟 $B$ 不一樣的地方來看，我們一定會發現 $A$ 比 $B$ 不來的差。  

* 如果 $B$ 那部分的第一個比 $A$ 那部分的第一個早結束呢？  
不可能發生，因為 $A$ 的策略是「從當下最早結束的開始看」  

* 如果 $B$ 那部分比 $A$ 那部分看的還要多呢？  
不可能發生，因為 $A$ 第一個在比 $B$ 更早結束的情況下， $A$ 是有辦法接上 $B$ 的那組解的，因為我們選的比 $B$ 那組解至少在下一步會找到一樣好的，如此反覆下去 $B$ 是沒有機會贏過 $A$ 的  

換句話說，這樣的 Greedy 是成功的！  

總時間複雜度 $O(N log (N))$  

---

> ### 6. 快取替換問題  
> 你有 2 個炒菜鍋，一開始都是乾淨的
> 接下來你要炒 N 道菜，如果這個炒菜鍋是乾淨的
> 或是上次炒的菜跟這次炒的菜是一樣的才能炒，否則就須要洗鍋子
> 洗鍋子很花時間，所以你想盡量洗少次一點，請問最少是多少次？

Greedy：如果有鍋子已經炒過／乾淨的就先用，但如果沒有，該洗哪個鍋子？  

洗出現最少／之後出現最少的：  
$\{ 1; 2; 3; 2; 3; 2; 1; 1; 1; 1 \}$  

如果一道菜很快就會被炒，那我們是不是就會懶得洗那道菜的鍋子？  

粗略的證明：  
現在鍋子裡分別是 $\{ A; B \}$ ，接下來要炒的順序是  
$\{ C \cdots ^1 A \cdots ^2 B \cdots ^3 \}$  

* 選擇洗掉 A  
如果 $\cdots ^2$ 出現了 $C$ ，那我們把 $A$ 洗成 $C$ 就會被洗回來，可能要多洗 $1$ 次  
* 選擇洗掉 B  
再遇到這樣的情況就可以避免  

---

> ### 7. 最小字典序問題
> 你有 N 個長度小於 L 的字串，問在所有把它們串接起來的方法中，字典序最小的是多少？  
> $N \leq 5 \cdot 10^4; L \leq 50$

如果直接照字典序 sort，好像不會對  
反例： $\{$ ba $;$ b $\}$  

想簡單一點的情況：如果 $N = 2$  
直接把 $a_1$ 跟 $a_2$ 看 $a_1 + a_2$ 還是 $a_2 + a_1$ 比較小看看  
那 $N = 3$ 呢？  
如果直接用這個條件 sort 會好嗎？  

如果這個比較關係可以 sort，那我們就試試看 Bubble Sort，每次交換就可以想成「如果換了會更好就換」，這樣只要 sort 出來就會換不了，也就是說是最佳解。  
在 Bubble Sort 是好的條件下，就可以用各種是 $O(N log(N))$ 的 sort（例如 std::sort）。  
但 sort 為什麼是好的，難道不會換到停不下來嗎？  

如果我們定義 $S$ 跟 $T$ 兩個字串，我們想要說 $S < T$ 如果 $S + T$ 的字典序比 $T + S$ 小  
想要讓 sort 要是好的，就要讓 $<$ 有它該有的樣子  

* $S \ge S$
很顯然，因為 $S + S$ 跟 $S + S$ 的字典序是一樣的  
* $U$ 也是字串，則 $S < U ; U < T \rightarrow S < T$
我們把一個字串寫成數字的樣子，也就是說，如果字元集的大小是 $\Sigma$ ，定義 $S = S_1\Sigma^{|S|-1} + S_2\Sigma^{|S|-2} + \cdots + S_{|s|}\Sigma^{0}$
這樣 $S + T$ 的字典序比 $T + S$ 小就表示
$S \cdot \Sigma^{|T|} + T < T \cdot \Sigma^{|S|} + S$
移項得到 $\frac{S}{\Sigma^{|S|}-1} < \frac{T}{\Sigma^{|T|}-1}$ ，換句話說可以想成每個字串都可以用一個值去代表他，那顯然就會滿足遞移律了  

也就是說，你可以把它當作一種 $<$ ，這樣 sort 是好的  

這樣我們就有總時間複雜度是 $O(N \cdot L log (N) )$ 的 Greedy 做法了  












