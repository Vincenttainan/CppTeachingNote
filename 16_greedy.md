# **C++ 筆記**  
## 貪心 Greedy  

貪心算法，是在每一步選擇中都採取 **當前最佳的選擇** ，希望最終能達到整個問題的最佳解。這種方法基於局部最優選擇，希望能導向全局最優解  

其實也就是在能確保 **未來最佳解** ，必定需要經過 **目前最佳解** 時，便可以使用貪心算法  

## 優點：  

1. 簡單易懂，易於實現  
2. 適用於某些特定類型的問題，如  
     * 活動選擇問題  
     * 最小生成樹問題（如 Kruskal 和 Prim 算法）  
     * 單源最短路徑問題（如 Dijkstra 算法）  

## 缺點：  

1. 不能保證對所有問題都能找到全局最優解  
2. 需要問題本身具有特定性質才能應用  

## 一些 Greedy 範例  

> ### 1. 最基本的 Greedy  
>桌上有 $N$ 個物品，第 $i$ 個物品有價值 $a_i$，你可以拿走 $K$ 個  
>在你想要最大化價值的情況底下，最大是多少？  

> 最直覺的想法是拿前 $K$ 大的，顯然這也是最好的辦法  
> Greedy 的感覺就是訂好一個策略，往當下最好的走，嘗試看看會不會是最好的  

---

> ### 2. 找零錢問題  
> 有 $N$ 種幣值，第 $i$ 種幣值是 $b_i$ ，同時保證：  
> 
> 1. 對於 $1 \leq i < N$ ， 都有 $b_i > b_{i+1}$  
> 2. $b_{i+1}$ 整除 $b_i$  
> 3. $b_N = 1$  
> 
> 今天你是一個超商店員，你想用這些幣值湊出 $K$ 元，但你又不想給顧客太多零錢，因此你想找出零錢總數最少的方法  
> 給定 $N$ , $b_i$ , $K$ 請求出這個最小值是多少  

> 想想看生活中的解決方式  
> 
> 從幣值最大的最多的開始嘗試拿，直到拿完為止  
> 這樣好像是對的，真的是對的嗎？  
> 
> 我們把兩個不同的方案都按照幣值小的開始排序，定義 $A$ 是剛剛方法做出來的方案 $B$ 是任何其他的方案  

```mermaid
gantt
section 找錢方式
全部要找的錢：15 :active,  des1, 2000-1-1, 15d
方法 A：6   :         desA1, 2000-1-1, 6d
方法 A：6   :         desA2, 2000-1-7, 6d
方法 A：3   :         desA3, 2000-1-13, 3d
方法 B：6   :         desB1, 2000-1-1, 6d
方法 B：3   :         desB2, 2000-1-7, 3d
方法 B：3   :         desB3, 2000-1-10, 3d
方法 B：3   :         desB3, 2000-1-13, 3d
```

> 在第一個 $A$ 跟 $B$ 不一樣的地方來看，找 $A$ 的一個一定可以對應到 B 的一部分  
> 
> * 如果 $B$ 那部分的第一個比 $A$ 那部分的第一個大呢？  
>   不可能發生,因為 $A$ 的策略是「從大的開始試」。  
> * 如果 $A$ 的第一個對下去沒有完整的對到一些零錢呢？  
>   不可能發生，因為小零錢可以整除大零錢，不可能沒對到。  
>   
> 所以說,我們可以發現 $B$ 在這部分就輸了  
> 換句話說， $A$ 一定是最好的，Greedy 成功！  

---

> ### 2.ex. 找零錢問題（改）  
> 有 $N$ 種幣值，第 $i$ 種幣值是 $b_i$ ，~~同時保證：~~  
> 
> ~~1. 對於 $1 \leq i < N$ ， 都有 $b_i > b_{i+1}$~~  
> ~~2. $b_{i+1}$ 整除 $b_i$~~  
> ~~3. $b_N$ = $1$~~  
> 
> 今天你是一個超商店員，你想用這些幣值湊出 $K$ 元，但你又不想給顧客太多零錢，因此你想找出零錢總數最少的方法  
> 給定 $N$ , $b_i$ , $K$ 請求出這個最小值是多少  
> 
> 也就是之前保證的三點都不存在了  

> 那這樣同樣的 Greedy 還有效嗎？  
> 
> $N = 3$ ; $b = \{10, 9, 1\}$ ; $K = 27$  
> 可以發現你會找到一組不好的解  
> 用原本的方式找錢會找除 $\{10, 10, 1, 1, 1, 1, 1, 1, 1\}$ 共 $9$ 個零錢  
> 然而用手算一下會發現其實可以用 $\{9, 9, 9\}$ 共 $3$ 個零錢完成任務  
> 要怎麼解決這個問題？ 之後會講的DP就可以處理這個問題了！
